知识点记录

1. spring作为开发平台，对数据库的访问支持的很完善，对事务的支持也比较完善，主要分为两种编程式事务与声明式事务，编程式事务能够更细的控制事务回滚与提交的粒度，但是需要在代码中编写，耦合性更高，并且与业务代码混合在一起，这与spring的无入侵的特性相违背，因此一般会采用声明式事务的方式进行事务管理，因为在很多需要操作数据的逻辑都需要进行事务管理，抛开不同开发者写的代码差异性不谈，单从重复性的代码导致系统难以维护，内聚性很差这点就足以证明这种方式不可取，但是这不正是AOP的使用场景吗，因此使用切面编程技术生成动态代理完成事务管理，业务代码更加的单纯，。主要分为三大部分，数据源，事务管理器，代理机制。其中处于核心地位的接口为PlatformTransactionManager

2. Java中IO是以流为基础进行输入输出的，所有数据被串行化写入输出流，或者从输入流读入。
3. NIO是为了弥补IO操作的不足而诞生的，NIO的一些新特性有：非阻塞I/O，选择器，缓冲以及管道。管道（Channel），缓冲（Buffer） ，选择器（ Selector）是其主要特征
	Channel——管道实际上就像传统IO中的流，到任何目的地(或来自任何地方)的所有数据都必须通过一个 Channel 对象。
	一个 Buffer 实质上是一个容器对象。

每一种基本 Java 类型都有一种缓冲区类型：
ByteBuffer——byte
CharBuffer——char

ShortBuffer——short

IntBuffer——int
 
LongBuffer——long
 
FloatBuffer——float
 
DoubleBuffer——double
Selector——选择器用于监听多个管道的事件，使用传统的阻塞IO时我们可以方便的知道什么时候可以进行读写，而使用非阻塞通道，我们需要一些方法来知道什么时候通道准备好了，选择器正是为这个需要而诞生的。

为什么HashMap链表长度超过8会转成树结构

HashMap在JDK1.8及以后的版本中引入了红黑树结构，若桶中链表元素个数大于等于8时，链表转换成树结构；若桶中链表元素个数小于等于6时，树结构还原成链表。因为红黑树的平均查找长度是log(n)，长度为8的时候，平均查找长度为3，如果继续使用链表，平均查找长度为8/2=4，这才有转换为树的必要。链表长度如果是小于等于6，6/2=3，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短。

还有选择6和8，中间有个差值7可以有效防止链表和树频繁转换。假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。